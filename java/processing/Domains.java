package processing;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import data.Domain;
import data.Mapping;
import functions.Constants;
import functions.Static;

public class Domains {

  /**
   * Partially parses a download of Interpro's hierarchy into files listing the short names of domains and protein-binding domains, each.
   *
   * Input file: interpro.xml
   * Output files: interpro.domains.txt, interpro.binding_domains.txt
   *
   * @throws IOException
   */
  public static void writeInterproFiles() throws IOException {
    BufferedReader in = new BufferedReader(new FileReader("interpro.xml"));
    String line = "";

    ArrayList<String> domainNames = new ArrayList<String>();
    ArrayList<String> bindingDomainNames = new ArrayList<String>();
    String newDomainName = null;
    boolean isBinding = false;

    while ((line = in.readLine()) != null) {
      line = line.trim();
      if (line.startsWith("<interpro") && line.contains("type=\"Domain\"")) {
        int startIndex = line.indexOf("short_name=") + "short_name=".length() + 1;
        int endIndex = line.indexOf('"', startIndex);
        newDomainName = line.substring(startIndex, endIndex);
      }

      if (line.trim().equals("<classification id=\"GO:0005515\" class_type=\"GO\">")) {
        isBinding = true;
      }

      // End of Interpro entry
      if (line.startsWith("</interpro")) {
        if (newDomainName != null) {
          domainNames.add(newDomainName);
          if (isBinding) {
            bindingDomainNames.add(newDomainName);
          }
        }

        // Reset for next Interpro entry
        newDomainName = null;
        isBinding = false;
      }
    }
    in.close();

    Collections.sort(domainNames);
    Collections.sort(bindingDomainNames);

    BufferedWriter out = new BufferedWriter(new FileWriter("interpro_domains.txt"));
    for (String domainName: domainNames) {
      out.write(domainName + "\n");
    }
    out.close();

    out = new BufferedWriter(new FileWriter("interpro.binding_domains.txt"));
    for (String domainName: bindingDomainNames) {
      out.write(domainName + "\n");
    }
    out.close();
  }

  /**
   * Static method to read in a list of Interpro domains' short names. File is generated by Domain.writeInteroproFiles()
   *
   * Input files: interpro.domains.txt
   *
   * @return
   * @throws IOException
   */
  public static HashSet<String> interproDomainNames() throws IOException {
    HashSet<String> result = new HashSet<String>();
    String line = "";
    BufferedReader in = new BufferedReader(new FileReader("interpro.domains.txt"));

    while ((line = Static.skipBlankCommentLines(in)) != null) {
      result.add(line.trim());
    }

    in.close();
    return result;
  }

  /**
   * Static method to read in a list of Interpro protein-binding domains' short names. File must be manually maintained.
   *
   * Input files: interpro.binding_domains.txt
   *
   * @return
   * @throws IOException
   */
  public static HashSet<String> interproBindingDomainNames() throws IOException {
      HashSet<String> result = new HashSet<String>();
      String line = "";
      BufferedReader in = new BufferedReader(new FileReader("interpro.binding_domains.txt"));

      while ((line = Static.skipBlankCommentLines(in)) != null) {
          result.add(line.trim());
      }

      in.close();
      return result;
  }

  /**
   * Reads in one of the protein-domain listings generated by the Perl script, and replaces remnant
   * Interpro codes with domain names. Required due to bugginess of Ensembl database.
   *
   * Input filename: interpro.short_names.dat, ???.protein_domains.all.txt
   * Output filename: ???.protein_domains.all.processed.txt
   *
   * @param speciesName - the species for which domain listings are to be reproccessed; implied
   *        subdirectory for file locations
   * @throws Exception
   */
  public static void processDomainFiles(String speciesName) throws Exception {
    // Mapping of Interpro accession numbers to short names, because Ensembl is missing a lot of
    // them
    Mapping interpro = new Mapping("short_names.dat", "\t", 0, 1);

    BufferedReader in = new BufferedReader(new FileReader(speciesName + "/" + speciesName + ".protein_domains.all." + Constants.FILE_VERSION + ".txt"));
    String line = "";
    StringBuffer output = new StringBuffer();

    while ((line = Static.skipCommentLines(in)) != null) {
      ArrayList<Domain> rawDomains = new ArrayList<Domain>();
      String[] split = line.split("\t");

      // Pass through the name and ID of the protein
      if (split[0].trim().length() == 0) {
        split[0] = split[1];
      }
      output.append(split[0] + "\t" + split[1]);


      // Each domain needs to have its Interpro accession number replaced with its Interpro short name
      for (int i = 2; i < split.length; i++) {
        String[] split2 = split[i].split(",");
        String name = split2[0];
        String firstSource = split2[3];

        // Skip domains annotated only by Superfamily. Too unreliable.
        if (split2.length == 4 && firstSource.equals("superfamily")) {
          continue;
        }

        try {
          name = Static.getFirstFromSet(interpro.getForward(split2[0])); // Only one entry in the set
        }
        catch (NullPointerException npe) {}

        rawDomains.add(new Domain(name, Integer.parseInt(split2[1]), Integer.parseInt(split2[2]), split2[3]));
      }

      // Domain merging procedure; domains should already be sorted by start position, from Perl script
      ArrayList<Domain> mergedDomains = new ArrayList<Domain>(); // Data structure to hold final list of merged domains
      for (int i = 0; i < rawDomains.size(); i++) {
        Domain domain1 = rawDomains.get(i);
        boolean toAdd = true;

        // See if this new domain overlaps with any already recorded domains, in both sequence and type
        for (int j = mergedDomains.size() - 1; j >= 0; j--) {
          Domain domain2 = mergedDomains.get(j);
          int overlap = -1;

          // Domains are of the same Interpro type, or both SH3 domains of some sort
          if ((domain1.name.equals(domain2.name) || Domain.sh3Match().contains(domain1.name) && Domain.sh3Match().contains(domain2.name))) {
            // We know that domain1 starts before domain2, but their end points might be in either order, so we need to check both cases.
            // Below code is generic, works regardless of domain start order

            // If domain1 ends somewhere within domain2: looking for overlap
            if (domain1.end >= domain2.start && domain1.end <= domain2.end) {
              overlap = Math.min(domain1.length(), domain1.end - domain2.start + 1);
            }
            // If domain2 ends somewhere within domain1 - looking for other overlap case
            else if (domain2.end >= domain1.start && domain2.end <= domain1.end) {
              overlap = Math.min(domain2.length(), domain2.end - domain1.start + 1);
            }
          }

          // There exists overlap and it is significant (more than half the domain's length). Now
          // merge the domains.
          if (overlap > domain1.length() / 2) {
            // We merge by changing the positions of domain2, which is already in the list of merged domains
            domain2.start = Math.min(domain1.start, domain2.start);
            domain2.end = Math.max(domain1.end, domain2.end);
            if (!domain2.source.contains(domain1.source)) {
              ArrayList<String> sources = new ArrayList<String>(Arrays.asList(domain2.source.split(",")));
              sources.add(domain1.source);
              Collections.sort(sources);
              domain2.source = "";
              for (String source: sources) {
                domain2.source += source + ";";
              }
              domain2.source = domain2.source.substring(0, domain2.source.length() - 1);
            }

            toAdd = false;
            break; // New domain can only overlap with one previous domain. (Otherwise, earlier domains would have been merged.)
          }
        }

        // If no overlapping domain with the same name was found, add our domain to the list of unique domains
        if (toAdd) {
          mergedDomains.add(domain1);
        }

      }

      // Store all properly processed domains in output buffer
      for (Domain domain: mergedDomains) {
        output.append("\t" + domain.name + "," + domain.start + "," + domain.end + "," + domain.source);
      }
      output.append("\n");

    }

    in.close();

    // Write output file
    BufferedWriter out = new BufferedWriter(new FileWriter(speciesName + "/" + speciesName + ".protein_domains.all.processed." + Constants.FILE_VERSION + ".txt"));
    out.write(output.toString());
    out.close();
  }

  /*public static void main(String[] args) throws Exception {
    Domains.writeInterproFiles();


    String[] specieses = {"H.sapiens", "M.musculus", "R.norvegicus", "D.rerio", "D.melanogaster", "C.elegans", "S.cerevisiae"};
    //String[] specieses = {"H.sapiens"};

    for (String species: specieses) {
      //Domain.processDomainFiles(species);
      //Domain.gatherSH3Sequences(species);
      //Domain.filterSh3Proteins(species);
    }
  }*/
}
